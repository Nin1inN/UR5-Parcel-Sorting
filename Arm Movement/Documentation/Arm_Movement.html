<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>Arm_Movement API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Arm_Movement</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import socket
import json
import numpy as np
import time
import threading
import math
#import rtde_control
#import rtde_receive
import cv2
import pyrealsense2
from queue import Queue
from threading import Event



# armVelocity = 0

#For the demo, there will only be one drop position.
#However, for future projects, more can be added
#Will be set to a default position, however, user can change this
# place_position = np.zeros(6)


#Ready to add other functions for arm movement






class Arm_Movement:
    def __init__(self):
        
        &#34;&#34;&#34;
        Constructor:
            
        Setups up the parameters used by the rest of the system.
        
        Args: 
            
            None.

        Returns: 
            
            None.

        &#34;&#34;&#34;
        self.serverIP = &#39;127.0.0.1&#39;
        self.serverPORT = 6000
        self.armIP = &#34;10.0.0.4&#34;
        self.armPORT = 30002
        self.systemStatus = &#34;Offline&#34;
        
    
    def setup(self):
        
        &#34;&#34;&#34;
        Connects Arm Movement to the UR5 and the Server.
        
        Starts up the rest of the functionality for the class. 
        
        Args: 
            
            None.

        Returns: 
            
            None.

        &#34;&#34;&#34;
        
        
        
        connected = False

        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
        rtde_c = 0
        rtde_r = 0
    
        #Connect to arm
        while not(connected):
            try:
                #rtde_c = rtde_control.RTDEControlInterface(self.armIP)
               # rtde_r = rtde_receive.RTDEReceiveInterface(self.armIP)
                connected = True
            except Exception as e:
                print(e)
            finally:
                time.sleep(1)
    
        #Move arm to home position
    
    
        # Connect to server.
        connected = False
        while not(connected):
            try:
                conn.connect((self.serverIP, self.serverPORT))
                connected = True
            except Exception as e:
                print(e)
            finally:
                time.sleep(1)
    
    
        q = Queue()
        # t1 = threading.Thread(target = self.moniterUserInput, args = (q, conn, ))
        t2 = threading.Thread(target = self.TCPwrapper, args = (q, conn, rtde_c, rtde_r,  ))
    
        #t1.start()
        t2.start()
    
        #t1.join()
        t2.join()
        
        

    #z axis = 109mm at workcell level.
    #Tells server ready for TCP values
    def TCPwrapper(self, in_q, conn, rtde_c, rtde_r):
  
        
        &#34;&#34;&#34;
        Main control logic for the arm. Moves and moniters the arm for pick and place operation. 
        
        Tracks the position of the arm and moniters input from the user.
        
        Requests TCP values when in home position (system just started or dropped a parcel and ready for the next).
        
        Args: 
            
            in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Used to moniter input from the user (network).
                
            conn (socket): Socket connected to server.
                
            rtde_c (class): Control interface for the arm (send data). 
                
            rtde_r (class): Receive interface for the arm (read data).

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        #For testing purposes
        self.systemStatus = &#34;Online&#34;
    
    
    
        #Place holders, set to defaults
        home_position = np.array([-0.093, -0.486, 0.530, 1.56, -2.62, -0.03])
        armVelocity = 0.3
    
        targetTCP = np.zeros(6)
        place_position = np.zeros(6)
    
    
        #Used for testing, remove for final version
        # jsonResult = {&#34;first&#34;: &#34;TCP Values&#34;, &#34;second&#34;: &#34;-0.514&#34;, &#34;third&#34;: &#34;-0.029&#34; , &#34;fourth&#34;: &#34;0.220&#34; , &#34;fifth&#34;: &#34;1.05&#34; , &#34;sixth&#34;: &#34;-3&#34;, &#34;seventh&#34;: &#34;-0.15&#34;  }
        #
        #
        # in_q.put(jsonResult)
        #
        # jsonResult = {&#34;first&#34;: &#34;Place Location&#34;, &#34;second&#34;: &#34;-0.050&#34;, &#34;third&#34;: &#34;-0.565&#34; , &#34;fourth&#34;: &#34;0.270&#34; , &#34;fifth&#34;: &#34;1.05&#34; , &#34;sixth&#34;: &#34;-3&#34;, &#34;seventh&#34;: &#34;-0.15&#34;  }
        #
        # in_q.put(jsonResult)
    
        while (True):
    
    
            if(self.systemStatus == &#34;Online&#34;):
    
    
                    jsonResult = {&#34;first&#34;:&#34;ARM&#34;, &#34;second&#34;: &#34;Ready for TCP Values&#34;}
                    self.send(conn, jsonResult)
    
    
    
                    #Will empty queue at the beginning of each sequence
                    #May check for velocity changes between each section.
                    while(in_q.empty() == False):
                        jsonReceived = in_q.get()
    
                        if(jsonReceived[&#34;first&#34;] == &#34;TCP Values&#34;):
                            targetTCP[0] = float(jsonReceived[&#34;second&#34;])
                            targetTCP[1] = float(jsonReceived[&#34;third&#34;])
                            targetTCP[2] = float(jsonReceived[&#34;fourth&#34;])
                            targetTCP[3] = float(jsonReceived[&#34;fifth&#34;])
                            targetTCP[4] = float(jsonReceived[&#34;sixth&#34;])
                            targetTCP[5] = float(jsonReceived[&#34;seventh&#34;])
    
                        elif(jsonReceived[&#34;first&#34;] == &#34;Place Location&#34;):
                            place_position[0] = float(jsonReceived[&#34;second&#34;])
                            place_position[1] = float(jsonReceived[&#34;third&#34;])
                            place_position[2] = float(jsonReceived[&#34;fourth&#34;])
                            place_position[3] = float(jsonReceived[&#34;fifth&#34;])
                            place_position[4] = float(jsonReceived[&#34;sixth&#34;])
                            place_position[5] = float(jsonReceived[&#34;seventh&#34;])
    
                        elif(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                            armVelocity = jsonReceived[&#34;second&#34;]
    
                    #Async allows us to stop the arm
                    #For safety or other issues
    
    
                    #Called here so if user changes place position while arm is in seqeuence, changes for next sequence.
    
                    #Not doing a current velocity since the user will likely will want the arm to change velocity as quickly as possible
    
                    #This section moves the arm to pickup a package
                    self.movRobot(rtde_c, targetTCP, armVelocity, 0.6, True, False)
                    time.sleep(1)
    
                    #armPosition = &#34;Unknown&#34;
    
                    self.checkTCPValues(rtde_r, rtde_c, targetTCP, armVelocity)
                    #
                    # pickParcel()
                    #
                    # #################################################################
                    #
                    # armVelocity = checkVelocity(in_q, armVelocity)
                    #
                    # #This section moves the arm to parcel drop location
                    self.movRobot(rtde_c, place_position, armVelocity, 1, True, True)
                    time.sleep(1)
    
    
                    self.checkTCPValues(rtde_r, rtde_c, place_position, armVelocity)
                    #
                    # placeParcel()
    
                    #################################################################
    
                    # armVelocity = checkVelocity(in_q, armVelocity)
                    #
                    self.movRobot(rtde_c, home_position, armVelocity, 1, True, False)
                    time.sleep(1)
    
                    self.checkTCPValues(rtde_r, rtde_c, home_position, armVelocity)
    
                    #Arm at home position, ready to repeat
    
                    #armPosition =  &#34;Home&#34;
    
    
    
    
    
    
    #Ready for code
    def pickParcel(self):
        
        
        #At this point (in checkTCPValues) can read the sensor (switch), if nothing, move lower in the z axis by small increments)
        pass
    
    #Ready for code
    def placeParcel(self):
        pass
    
    def stopRobot(self, rtde_c):
        
        &#34;&#34;&#34;
        Stops the arm with a joint deceleration of 2 rad/s^2
        
        Args: 
            
            rtde_c (class): Control interface for the arm (send stop command to arm). 

        Returns: 
            
            None.

        &#34;&#34;&#34;
        rtde_c.stopJ(2.0)
        
        
    
    def movRobot(self, rtde_c, targetTCP,v, a, asyn, payload):
        
        &#34;&#34;&#34;
        Moves the arm to the given targetTCP values.
        
        Depending on the velocity mode (ECO or constant), moves the arm at different speeds. 
        
        Args: 
            
            rtde_c (class): Control interface for the arm (send move command to arm). 
            
            targetTCP (list): TCP values for arm to move to. 
            
            v (int): velocity for arm (either value from 0 to 100 or ECO).
            
            a (int): accleration for arm.
            
            asyn (bool): Allows the arm to run in asynchronous mode
            
            payload (bool): Whether the arm currently has a payload (used in ECO mode)

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        if(v == &#34;ECO&#34;):
            if(payload == False):
                print()
                #Move at higher velocity
                rtde_c.moveL(targetTCP, v, a, asyn)
    
            elif(payload == True):
                print()
                #Reduce velocity by 20%
                rtde_c.moveL(targetTCP, v, a, asyn)
    
        else:
            #Assuming if v != ECO, is a int in string format
            v = int(v)
            rtde_c.moveL(targetTCP, 0.1, 0.1, asyn)
            print(&#34;MOVING TO POSITION&#34;)
    
    
    def checkVelocity(self, in_q, currentArmVelocity):
        
        &#34;&#34;&#34;
        Checks the Queue to see if a arm velocity change has been received from the server.
        
        Returns new velocity, otherwise returns the current velocity.
        
        
        Args: 
            
            in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). 
            
            currentArmVelocity (int): If no velocity change (or queue is empty), returns this value.

        Returns: 
            
            armVelocity (int or string): New velocity for arm

        &#34;&#34;&#34;
    
        if (in_q.empty() == False):
    
            jsonReceived = in_q.get()
    
            if(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                armVelocity = jsonReceived[&#34;second&#34;]
                return armVelocity
        else:
            #Get pops the data from the queue, putting data back into queue
            in_q.put(jsonReceived)
            return currentArmVelocity
    
    
    
    #This function will be used to compare target TCP vs current TCP
    def checkTCPValues(self, rtde_r, rtde_c, targetTCP, armVelocity):
        
        &#34;&#34;&#34;
        Checks current TCP values of UR5 against target TCP values.
        
        Moniters input from user (e.g. system go into standby). Will restart arm movement if system goes into standby. 
        
        Args: 
            
            rtde_c (class): Control interface for the arm (restart arm movement if system pauses).
            
            rtde_r (class): Receive interface for the arm (get current TCP values of UR5).
            
            targetTCP (list): TCP values for arm to move to. 
            
            armVelocity (int or string): velocity for arm (either value from 0 to 100 or ECO).
            
            

        Returns: 
            
            None.

        &#34;&#34;&#34;
        
        
     
        flag = 0
    
        currentTCPValues = rtde_r.getActualTCPPose()
    
        currentTCPValues = currentTCPValues[0:3]
    
        targetTCP = targetTCP[0:3]
    
        # print(&#34;Current TCP Values&#34; + str(currentTCPValues))
        # print(&#34;Target TCP Values&#34; + str(targetTCP))
    
        #Run in loop until arm arrives at targetTCP
        #Flag varible is used to moniter if the system is online
        #If flag is set to 1, means system stopped at some point.
        #Need to finish the last step before moving on.
        while ( np.allclose(currentTCPValues, targetTCP, 0.01) == False) :
    
            # print(&#34;Current TCP Values&#34; + str(currentTCPValues))
            # print(&#34;Target TCP Values&#34; + str(targetTCP))
            try:
                currentTCPValues = rtde_r.getActualTCPPose()
                time.sleep(1)
                currentTCPValues = currentTCPValues[0:3]
    
                if(flag == 0):
    
                    if(self.systemStatus != &#34;Online&#34;):
                        flag = 1
                        self.stopRobot(rtde_c)
    
                elif(self.systemStatus == &#34;Online&#34;):
    
                    if(flag == 1):
                        self.movRobot(rtde_c, targetTCP, armVelocity, 1, True)
            except Exception as error:
                print(error)
                print(&#34;Error is caught here&#34;)
                self.movRobot(rtde_c, targetTCP, armVelocity, 0.6, True, False)
    
                #currentTCPValues = rtde_r.getActualTCPPose()
                
        
        
    
    
    def receive(self, conn):
        
        &#34;&#34;&#34;
        Returns data received from server.
        
        Args: 
            
            conn (socket): socket connected to server.

        Returns: 
            
            jsonReceived (JSON - dictionary): returns json data. 
        &#34;&#34;&#34;
        jsonReceived = conn.recv(1024)
        jsonReceived = json.loads(jsonReceived.decode(&#34;utf-8&#34;))
        return jsonReceived
    
    def send(self, conn, data):
        
        &#34;&#34;&#34;
        Sends data to the server. 
        
        Args: 
            
            conn (socket): socket connected to server.
            
            data (JSON - dictionary): data to send. 

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        jsonResult = json.dumps(data)
        conn.send(bytes(jsonResult, encoding=&#34;utf-8&#34;))
    
    
    def moniterUserInput(self, out_q, conn):
        
        &#34;&#34;&#34;
        Moniters data received from the server and performs the command receieved. 
        
        Args: 
            
            out_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Puts commands on the queue for TCPWrapper to use. 
                
            conn (socket): socket connected to server.

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        while(True):
            jsonReceived = self.receive(conn)
    
            #Add commands for this script
            #System Pasue, shutdown, velocity change, etc.
    
            if(jsonReceived[&#34;first&#34;] == &#34;System Started&#34;):
                print(&#34;System online&#34;)
                self.systemStatus = &#34;Online&#34;
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Go into Standby&#34;):
                print(&#34;System in standby&#34;)
                self.systemStatus = &#34;Standby&#34;
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Shut Down System&#34;):
                print(&#34;System offline&#34;)
                self.systemStatus = &#34;Offline&#34;
    
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                print(&#34;Velocity Change&#34;)
    
                out_q.put((jsonReceived))
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Place Location&#34;):
                print(&#34;Drop Location Changed&#34;)
    
                out_q.put((jsonReceived))
    
            elif(jsonReceived[&#34;first&#34;] == &#34;TCP Values&#34;):
                print(&#34;TCP Values&#34;)
    
                out_q.put((jsonReceived))



if __name__ == &#34;__main__&#34;:
    
     armControl = Arm_Movement()
     armControl.setup()
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Arm_Movement.Arm_Movement"><code class="flex name class">
<span>class <span class="ident">Arm_Movement</span></span>
</code></dt>
<dd>
<div class="desc"><h2 id="constructor">Constructor</h2>
<p>Setups up the parameters used by the rest of the system.</p>
<p>Args: </p>
<pre><code>None.
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Arm_Movement:
    def __init__(self):
        
        &#34;&#34;&#34;
        Constructor:
            
        Setups up the parameters used by the rest of the system.
        
        Args: 
            
            None.

        Returns: 
            
            None.

        &#34;&#34;&#34;
        self.serverIP = &#39;127.0.0.1&#39;
        self.serverPORT = 6000
        self.armIP = &#34;10.0.0.4&#34;
        self.armPORT = 30002
        self.systemStatus = &#34;Offline&#34;
        
    
    def setup(self):
        
        &#34;&#34;&#34;
        Connects Arm Movement to the UR5 and the Server.
        
        Starts up the rest of the functionality for the class. 
        
        Args: 
            
            None.

        Returns: 
            
            None.

        &#34;&#34;&#34;
        
        
        
        connected = False

        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
        rtde_c = 0
        rtde_r = 0
    
        #Connect to arm
        while not(connected):
            try:
                #rtde_c = rtde_control.RTDEControlInterface(self.armIP)
               # rtde_r = rtde_receive.RTDEReceiveInterface(self.armIP)
                connected = True
            except Exception as e:
                print(e)
            finally:
                time.sleep(1)
    
        #Move arm to home position
    
    
        # Connect to server.
        connected = False
        while not(connected):
            try:
                conn.connect((self.serverIP, self.serverPORT))
                connected = True
            except Exception as e:
                print(e)
            finally:
                time.sleep(1)
    
    
        q = Queue()
        # t1 = threading.Thread(target = self.moniterUserInput, args = (q, conn, ))
        t2 = threading.Thread(target = self.TCPwrapper, args = (q, conn, rtde_c, rtde_r,  ))
    
        #t1.start()
        t2.start()
    
        #t1.join()
        t2.join()
        
        

    #z axis = 109mm at workcell level.
    #Tells server ready for TCP values
    def TCPwrapper(self, in_q, conn, rtde_c, rtde_r):
  
        
        &#34;&#34;&#34;
        Main control logic for the arm. Moves and moniters the arm for pick and place operation. 
        
        Tracks the position of the arm and moniters input from the user.
        
        Requests TCP values when in home position (system just started or dropped a parcel and ready for the next).
        
        Args: 
            
            in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Used to moniter input from the user (network).
                
            conn (socket): Socket connected to server.
                
            rtde_c (class): Control interface for the arm (send data). 
                
            rtde_r (class): Receive interface for the arm (read data).

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        #For testing purposes
        self.systemStatus = &#34;Online&#34;
    
    
    
        #Place holders, set to defaults
        home_position = np.array([-0.093, -0.486, 0.530, 1.56, -2.62, -0.03])
        armVelocity = 0.3
    
        targetTCP = np.zeros(6)
        place_position = np.zeros(6)
    
    
        #Used for testing, remove for final version
        # jsonResult = {&#34;first&#34;: &#34;TCP Values&#34;, &#34;second&#34;: &#34;-0.514&#34;, &#34;third&#34;: &#34;-0.029&#34; , &#34;fourth&#34;: &#34;0.220&#34; , &#34;fifth&#34;: &#34;1.05&#34; , &#34;sixth&#34;: &#34;-3&#34;, &#34;seventh&#34;: &#34;-0.15&#34;  }
        #
        #
        # in_q.put(jsonResult)
        #
        # jsonResult = {&#34;first&#34;: &#34;Place Location&#34;, &#34;second&#34;: &#34;-0.050&#34;, &#34;third&#34;: &#34;-0.565&#34; , &#34;fourth&#34;: &#34;0.270&#34; , &#34;fifth&#34;: &#34;1.05&#34; , &#34;sixth&#34;: &#34;-3&#34;, &#34;seventh&#34;: &#34;-0.15&#34;  }
        #
        # in_q.put(jsonResult)
    
        while (True):
    
    
            if(self.systemStatus == &#34;Online&#34;):
    
    
                    jsonResult = {&#34;first&#34;:&#34;ARM&#34;, &#34;second&#34;: &#34;Ready for TCP Values&#34;}
                    self.send(conn, jsonResult)
    
    
    
                    #Will empty queue at the beginning of each sequence
                    #May check for velocity changes between each section.
                    while(in_q.empty() == False):
                        jsonReceived = in_q.get()
    
                        if(jsonReceived[&#34;first&#34;] == &#34;TCP Values&#34;):
                            targetTCP[0] = float(jsonReceived[&#34;second&#34;])
                            targetTCP[1] = float(jsonReceived[&#34;third&#34;])
                            targetTCP[2] = float(jsonReceived[&#34;fourth&#34;])
                            targetTCP[3] = float(jsonReceived[&#34;fifth&#34;])
                            targetTCP[4] = float(jsonReceived[&#34;sixth&#34;])
                            targetTCP[5] = float(jsonReceived[&#34;seventh&#34;])
    
                        elif(jsonReceived[&#34;first&#34;] == &#34;Place Location&#34;):
                            place_position[0] = float(jsonReceived[&#34;second&#34;])
                            place_position[1] = float(jsonReceived[&#34;third&#34;])
                            place_position[2] = float(jsonReceived[&#34;fourth&#34;])
                            place_position[3] = float(jsonReceived[&#34;fifth&#34;])
                            place_position[4] = float(jsonReceived[&#34;sixth&#34;])
                            place_position[5] = float(jsonReceived[&#34;seventh&#34;])
    
                        elif(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                            armVelocity = jsonReceived[&#34;second&#34;]
    
                    #Async allows us to stop the arm
                    #For safety or other issues
    
    
                    #Called here so if user changes place position while arm is in seqeuence, changes for next sequence.
    
                    #Not doing a current velocity since the user will likely will want the arm to change velocity as quickly as possible
    
                    #This section moves the arm to pickup a package
                    self.movRobot(rtde_c, targetTCP, armVelocity, 0.6, True, False)
                    time.sleep(1)
    
                    #armPosition = &#34;Unknown&#34;
    
                    self.checkTCPValues(rtde_r, rtde_c, targetTCP, armVelocity)
                    #
                    # pickParcel()
                    #
                    # #################################################################
                    #
                    # armVelocity = checkVelocity(in_q, armVelocity)
                    #
                    # #This section moves the arm to parcel drop location
                    self.movRobot(rtde_c, place_position, armVelocity, 1, True, True)
                    time.sleep(1)
    
    
                    self.checkTCPValues(rtde_r, rtde_c, place_position, armVelocity)
                    #
                    # placeParcel()
    
                    #################################################################
    
                    # armVelocity = checkVelocity(in_q, armVelocity)
                    #
                    self.movRobot(rtde_c, home_position, armVelocity, 1, True, False)
                    time.sleep(1)
    
                    self.checkTCPValues(rtde_r, rtde_c, home_position, armVelocity)
    
                    #Arm at home position, ready to repeat
    
                    #armPosition =  &#34;Home&#34;
    
    
    
    
    
    
    #Ready for code
    def pickParcel(self):
        
        
        #At this point (in checkTCPValues) can read the sensor (switch), if nothing, move lower in the z axis by small increments)
        pass
    
    #Ready for code
    def placeParcel(self):
        pass
    
    def stopRobot(self, rtde_c):
        
        &#34;&#34;&#34;
        Stops the arm with a joint deceleration of 2 rad/s^2
        
        Args: 
            
            rtde_c (class): Control interface for the arm (send stop command to arm). 

        Returns: 
            
            None.

        &#34;&#34;&#34;
        rtde_c.stopJ(2.0)
        
        
    
    def movRobot(self, rtde_c, targetTCP,v, a, asyn, payload):
        
        &#34;&#34;&#34;
        Moves the arm to the given targetTCP values.
        
        Depending on the velocity mode (ECO or constant), moves the arm at different speeds. 
        
        Args: 
            
            rtde_c (class): Control interface for the arm (send move command to arm). 
            
            targetTCP (list): TCP values for arm to move to. 
            
            v (int): velocity for arm (either value from 0 to 100 or ECO).
            
            a (int): accleration for arm.
            
            asyn (bool): Allows the arm to run in asynchronous mode
            
            payload (bool): Whether the arm currently has a payload (used in ECO mode)

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        if(v == &#34;ECO&#34;):
            if(payload == False):
                print()
                #Move at higher velocity
                rtde_c.moveL(targetTCP, v, a, asyn)
    
            elif(payload == True):
                print()
                #Reduce velocity by 20%
                rtde_c.moveL(targetTCP, v, a, asyn)
    
        else:
            #Assuming if v != ECO, is a int in string format
            v = int(v)
            rtde_c.moveL(targetTCP, 0.1, 0.1, asyn)
            print(&#34;MOVING TO POSITION&#34;)
    
    
    def checkVelocity(self, in_q, currentArmVelocity):
        
        &#34;&#34;&#34;
        Checks the Queue to see if a arm velocity change has been received from the server.
        
        Returns new velocity, otherwise returns the current velocity.
        
        
        Args: 
            
            in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). 
            
            currentArmVelocity (int): If no velocity change (or queue is empty), returns this value.

        Returns: 
            
            armVelocity (int or string): New velocity for arm

        &#34;&#34;&#34;
    
        if (in_q.empty() == False):
    
            jsonReceived = in_q.get()
    
            if(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                armVelocity = jsonReceived[&#34;second&#34;]
                return armVelocity
        else:
            #Get pops the data from the queue, putting data back into queue
            in_q.put(jsonReceived)
            return currentArmVelocity
    
    
    
    #This function will be used to compare target TCP vs current TCP
    def checkTCPValues(self, rtde_r, rtde_c, targetTCP, armVelocity):
        
        &#34;&#34;&#34;
        Checks current TCP values of UR5 against target TCP values.
        
        Moniters input from user (e.g. system go into standby). Will restart arm movement if system goes into standby. 
        
        Args: 
            
            rtde_c (class): Control interface for the arm (restart arm movement if system pauses).
            
            rtde_r (class): Receive interface for the arm (get current TCP values of UR5).
            
            targetTCP (list): TCP values for arm to move to. 
            
            armVelocity (int or string): velocity for arm (either value from 0 to 100 or ECO).
            
            

        Returns: 
            
            None.

        &#34;&#34;&#34;
        
        
     
        flag = 0
    
        currentTCPValues = rtde_r.getActualTCPPose()
    
        currentTCPValues = currentTCPValues[0:3]
    
        targetTCP = targetTCP[0:3]
    
        # print(&#34;Current TCP Values&#34; + str(currentTCPValues))
        # print(&#34;Target TCP Values&#34; + str(targetTCP))
    
        #Run in loop until arm arrives at targetTCP
        #Flag varible is used to moniter if the system is online
        #If flag is set to 1, means system stopped at some point.
        #Need to finish the last step before moving on.
        while ( np.allclose(currentTCPValues, targetTCP, 0.01) == False) :
    
            # print(&#34;Current TCP Values&#34; + str(currentTCPValues))
            # print(&#34;Target TCP Values&#34; + str(targetTCP))
            try:
                currentTCPValues = rtde_r.getActualTCPPose()
                time.sleep(1)
                currentTCPValues = currentTCPValues[0:3]
    
                if(flag == 0):
    
                    if(self.systemStatus != &#34;Online&#34;):
                        flag = 1
                        self.stopRobot(rtde_c)
    
                elif(self.systemStatus == &#34;Online&#34;):
    
                    if(flag == 1):
                        self.movRobot(rtde_c, targetTCP, armVelocity, 1, True)
            except Exception as error:
                print(error)
                print(&#34;Error is caught here&#34;)
                self.movRobot(rtde_c, targetTCP, armVelocity, 0.6, True, False)
    
                #currentTCPValues = rtde_r.getActualTCPPose()
                
        
        
    
    
    def receive(self, conn):
        
        &#34;&#34;&#34;
        Returns data received from server.
        
        Args: 
            
            conn (socket): socket connected to server.

        Returns: 
            
            jsonReceived (JSON - dictionary): returns json data. 
        &#34;&#34;&#34;
        jsonReceived = conn.recv(1024)
        jsonReceived = json.loads(jsonReceived.decode(&#34;utf-8&#34;))
        return jsonReceived
    
    def send(self, conn, data):
        
        &#34;&#34;&#34;
        Sends data to the server. 
        
        Args: 
            
            conn (socket): socket connected to server.
            
            data (JSON - dictionary): data to send. 

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        jsonResult = json.dumps(data)
        conn.send(bytes(jsonResult, encoding=&#34;utf-8&#34;))
    
    
    def moniterUserInput(self, out_q, conn):
        
        &#34;&#34;&#34;
        Moniters data received from the server and performs the command receieved. 
        
        Args: 
            
            out_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Puts commands on the queue for TCPWrapper to use. 
                
            conn (socket): socket connected to server.

        Returns: 
            
            None.

        &#34;&#34;&#34;
    
        while(True):
            jsonReceived = self.receive(conn)
    
            #Add commands for this script
            #System Pasue, shutdown, velocity change, etc.
    
            if(jsonReceived[&#34;first&#34;] == &#34;System Started&#34;):
                print(&#34;System online&#34;)
                self.systemStatus = &#34;Online&#34;
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Go into Standby&#34;):
                print(&#34;System in standby&#34;)
                self.systemStatus = &#34;Standby&#34;
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Shut Down System&#34;):
                print(&#34;System offline&#34;)
                self.systemStatus = &#34;Offline&#34;
    
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                print(&#34;Velocity Change&#34;)
    
                out_q.put((jsonReceived))
    
            elif(jsonReceived[&#34;first&#34;] == &#34;Place Location&#34;):
                print(&#34;Drop Location Changed&#34;)
    
                out_q.put((jsonReceived))
    
            elif(jsonReceived[&#34;first&#34;] == &#34;TCP Values&#34;):
                print(&#34;TCP Values&#34;)
    
                out_q.put((jsonReceived))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Arm_Movement.Arm_Movement.TCPwrapper"><code class="name flex">
<span>def <span class="ident">TCPwrapper</span></span>(<span>self, in_q, conn, rtde_c, rtde_r)</span>
</code></dt>
<dd>
<div class="desc"><p>Main control logic for the arm. Moves and moniters the arm for pick and place operation. </p>
<p>Tracks the position of the arm and moniters input from the user.</p>
<p>Requests TCP values when in home position (system just started or dropped a parcel and ready for the next).</p>
<p>Args: </p>
<pre><code>in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Used to moniter input from the user (network).

conn (socket): Socket connected to server.

rtde_c (class): Control interface for the arm (send data).

rtde_r (class): Receive interface for the arm (read data).
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TCPwrapper(self, in_q, conn, rtde_c, rtde_r):

    
    &#34;&#34;&#34;
    Main control logic for the arm. Moves and moniters the arm for pick and place operation. 
    
    Tracks the position of the arm and moniters input from the user.
    
    Requests TCP values when in home position (system just started or dropped a parcel and ready for the next).
    
    Args: 
        
        in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Used to moniter input from the user (network).
            
        conn (socket): Socket connected to server.
            
        rtde_c (class): Control interface for the arm (send data). 
            
        rtde_r (class): Receive interface for the arm (read data).

    Returns: 
        
        None.

    &#34;&#34;&#34;

    #For testing purposes
    self.systemStatus = &#34;Online&#34;



    #Place holders, set to defaults
    home_position = np.array([-0.093, -0.486, 0.530, 1.56, -2.62, -0.03])
    armVelocity = 0.3

    targetTCP = np.zeros(6)
    place_position = np.zeros(6)


    #Used for testing, remove for final version
    # jsonResult = {&#34;first&#34;: &#34;TCP Values&#34;, &#34;second&#34;: &#34;-0.514&#34;, &#34;third&#34;: &#34;-0.029&#34; , &#34;fourth&#34;: &#34;0.220&#34; , &#34;fifth&#34;: &#34;1.05&#34; , &#34;sixth&#34;: &#34;-3&#34;, &#34;seventh&#34;: &#34;-0.15&#34;  }
    #
    #
    # in_q.put(jsonResult)
    #
    # jsonResult = {&#34;first&#34;: &#34;Place Location&#34;, &#34;second&#34;: &#34;-0.050&#34;, &#34;third&#34;: &#34;-0.565&#34; , &#34;fourth&#34;: &#34;0.270&#34; , &#34;fifth&#34;: &#34;1.05&#34; , &#34;sixth&#34;: &#34;-3&#34;, &#34;seventh&#34;: &#34;-0.15&#34;  }
    #
    # in_q.put(jsonResult)

    while (True):


        if(self.systemStatus == &#34;Online&#34;):


                jsonResult = {&#34;first&#34;:&#34;ARM&#34;, &#34;second&#34;: &#34;Ready for TCP Values&#34;}
                self.send(conn, jsonResult)



                #Will empty queue at the beginning of each sequence
                #May check for velocity changes between each section.
                while(in_q.empty() == False):
                    jsonReceived = in_q.get()

                    if(jsonReceived[&#34;first&#34;] == &#34;TCP Values&#34;):
                        targetTCP[0] = float(jsonReceived[&#34;second&#34;])
                        targetTCP[1] = float(jsonReceived[&#34;third&#34;])
                        targetTCP[2] = float(jsonReceived[&#34;fourth&#34;])
                        targetTCP[3] = float(jsonReceived[&#34;fifth&#34;])
                        targetTCP[4] = float(jsonReceived[&#34;sixth&#34;])
                        targetTCP[5] = float(jsonReceived[&#34;seventh&#34;])

                    elif(jsonReceived[&#34;first&#34;] == &#34;Place Location&#34;):
                        place_position[0] = float(jsonReceived[&#34;second&#34;])
                        place_position[1] = float(jsonReceived[&#34;third&#34;])
                        place_position[2] = float(jsonReceived[&#34;fourth&#34;])
                        place_position[3] = float(jsonReceived[&#34;fifth&#34;])
                        place_position[4] = float(jsonReceived[&#34;sixth&#34;])
                        place_position[5] = float(jsonReceived[&#34;seventh&#34;])

                    elif(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
                        armVelocity = jsonReceived[&#34;second&#34;]

                #Async allows us to stop the arm
                #For safety or other issues


                #Called here so if user changes place position while arm is in seqeuence, changes for next sequence.

                #Not doing a current velocity since the user will likely will want the arm to change velocity as quickly as possible

                #This section moves the arm to pickup a package
                self.movRobot(rtde_c, targetTCP, armVelocity, 0.6, True, False)
                time.sleep(1)

                #armPosition = &#34;Unknown&#34;

                self.checkTCPValues(rtde_r, rtde_c, targetTCP, armVelocity)
                #
                # pickParcel()
                #
                # #################################################################
                #
                # armVelocity = checkVelocity(in_q, armVelocity)
                #
                # #This section moves the arm to parcel drop location
                self.movRobot(rtde_c, place_position, armVelocity, 1, True, True)
                time.sleep(1)


                self.checkTCPValues(rtde_r, rtde_c, place_position, armVelocity)
                #
                # placeParcel()

                #################################################################

                # armVelocity = checkVelocity(in_q, armVelocity)
                #
                self.movRobot(rtde_c, home_position, armVelocity, 1, True, False)
                time.sleep(1)

                self.checkTCPValues(rtde_r, rtde_c, home_position, armVelocity)</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.checkTCPValues"><code class="name flex">
<span>def <span class="ident">checkTCPValues</span></span>(<span>self, rtde_r, rtde_c, targetTCP, armVelocity)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks current TCP values of UR5 against target TCP values.</p>
<p>Moniters input from user (e.g. system go into standby). Will restart arm movement if system goes into standby. </p>
<p>Args: </p>
<pre><code>rtde_c (class): Control interface for the arm (restart arm movement if system pauses).

rtde_r (class): Receive interface for the arm (get current TCP values of UR5).

targetTCP (list): TCP values for arm to move to.

armVelocity (int or string): velocity for arm (either value from 0 to 100 or ECO).
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkTCPValues(self, rtde_r, rtde_c, targetTCP, armVelocity):
    
    &#34;&#34;&#34;
    Checks current TCP values of UR5 against target TCP values.
    
    Moniters input from user (e.g. system go into standby). Will restart arm movement if system goes into standby. 
    
    Args: 
        
        rtde_c (class): Control interface for the arm (restart arm movement if system pauses).
        
        rtde_r (class): Receive interface for the arm (get current TCP values of UR5).
        
        targetTCP (list): TCP values for arm to move to. 
        
        armVelocity (int or string): velocity for arm (either value from 0 to 100 or ECO).
        
        

    Returns: 
        
        None.

    &#34;&#34;&#34;
    
    
 
    flag = 0

    currentTCPValues = rtde_r.getActualTCPPose()

    currentTCPValues = currentTCPValues[0:3]

    targetTCP = targetTCP[0:3]

    # print(&#34;Current TCP Values&#34; + str(currentTCPValues))
    # print(&#34;Target TCP Values&#34; + str(targetTCP))

    #Run in loop until arm arrives at targetTCP
    #Flag varible is used to moniter if the system is online
    #If flag is set to 1, means system stopped at some point.
    #Need to finish the last step before moving on.
    while ( np.allclose(currentTCPValues, targetTCP, 0.01) == False) :

        # print(&#34;Current TCP Values&#34; + str(currentTCPValues))
        # print(&#34;Target TCP Values&#34; + str(targetTCP))
        try:
            currentTCPValues = rtde_r.getActualTCPPose()
            time.sleep(1)
            currentTCPValues = currentTCPValues[0:3]

            if(flag == 0):

                if(self.systemStatus != &#34;Online&#34;):
                    flag = 1
                    self.stopRobot(rtde_c)

            elif(self.systemStatus == &#34;Online&#34;):

                if(flag == 1):
                    self.movRobot(rtde_c, targetTCP, armVelocity, 1, True)
        except Exception as error:
            print(error)
            print(&#34;Error is caught here&#34;)
            self.movRobot(rtde_c, targetTCP, armVelocity, 0.6, True, False)</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.checkVelocity"><code class="name flex">
<span>def <span class="ident">checkVelocity</span></span>(<span>self, in_q, currentArmVelocity)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the Queue to see if a arm velocity change has been received from the server.</p>
<p>Returns new velocity, otherwise returns the current velocity.</p>
<p>Args: </p>
<pre><code>in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication).

currentArmVelocity (int): If no velocity change (or queue is empty), returns this value.
</code></pre>
<p>Returns: </p>
<pre><code>armVelocity (int or string): New velocity for arm
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkVelocity(self, in_q, currentArmVelocity):
    
    &#34;&#34;&#34;
    Checks the Queue to see if a arm velocity change has been received from the server.
    
    Returns new velocity, otherwise returns the current velocity.
    
    
    Args: 
        
        in_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). 
        
        currentArmVelocity (int): If no velocity change (or queue is empty), returns this value.

    Returns: 
        
        armVelocity (int or string): New velocity for arm

    &#34;&#34;&#34;

    if (in_q.empty() == False):

        jsonReceived = in_q.get()

        if(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
            armVelocity = jsonReceived[&#34;second&#34;]
            return armVelocity
    else:
        #Get pops the data from the queue, putting data back into queue
        in_q.put(jsonReceived)
        return currentArmVelocity</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.moniterUserInput"><code class="name flex">
<span>def <span class="ident">moniterUserInput</span></span>(<span>self, out_q, conn)</span>
</code></dt>
<dd>
<div class="desc"><p>Moniters data received from the server and performs the command receieved. </p>
<p>Args: </p>
<pre><code>out_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Puts commands on the queue for TCPWrapper to use.

conn (socket): socket connected to server.
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moniterUserInput(self, out_q, conn):
    
    &#34;&#34;&#34;
    Moniters data received from the server and performs the command receieved. 
    
    Args: 
        
        out_q (Queue): Queue shared between TCPwrapper and moniterUserInput (allows for thread-safe communication). Puts commands on the queue for TCPWrapper to use. 
            
        conn (socket): socket connected to server.

    Returns: 
        
        None.

    &#34;&#34;&#34;

    while(True):
        jsonReceived = self.receive(conn)

        #Add commands for this script
        #System Pasue, shutdown, velocity change, etc.

        if(jsonReceived[&#34;first&#34;] == &#34;System Started&#34;):
            print(&#34;System online&#34;)
            self.systemStatus = &#34;Online&#34;

        elif(jsonReceived[&#34;first&#34;] == &#34;Go into Standby&#34;):
            print(&#34;System in standby&#34;)
            self.systemStatus = &#34;Standby&#34;

        elif(jsonReceived[&#34;first&#34;] == &#34;Shut Down System&#34;):
            print(&#34;System offline&#34;)
            self.systemStatus = &#34;Offline&#34;


        elif(jsonReceived[&#34;first&#34;] == &#34;Velocity Change&#34;):
            print(&#34;Velocity Change&#34;)

            out_q.put((jsonReceived))

        elif(jsonReceived[&#34;first&#34;] == &#34;Place Location&#34;):
            print(&#34;Drop Location Changed&#34;)

            out_q.put((jsonReceived))

        elif(jsonReceived[&#34;first&#34;] == &#34;TCP Values&#34;):
            print(&#34;TCP Values&#34;)

            out_q.put((jsonReceived))</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.movRobot"><code class="name flex">
<span>def <span class="ident">movRobot</span></span>(<span>self, rtde_c, targetTCP, v, a, asyn, payload)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the arm to the given targetTCP values.</p>
<p>Depending on the velocity mode (ECO or constant), moves the arm at different speeds. </p>
<p>Args: </p>
<pre><code>rtde_c (class): Control interface for the arm (send move command to arm).

targetTCP (list): TCP values for arm to move to.

v (int): velocity for arm (either value from 0 to 100 or ECO).

a (int): accleration for arm.

asyn (bool): Allows the arm to run in asynchronous mode

payload (bool): Whether the arm currently has a payload (used in ECO mode)
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def movRobot(self, rtde_c, targetTCP,v, a, asyn, payload):
    
    &#34;&#34;&#34;
    Moves the arm to the given targetTCP values.
    
    Depending on the velocity mode (ECO or constant), moves the arm at different speeds. 
    
    Args: 
        
        rtde_c (class): Control interface for the arm (send move command to arm). 
        
        targetTCP (list): TCP values for arm to move to. 
        
        v (int): velocity for arm (either value from 0 to 100 or ECO).
        
        a (int): accleration for arm.
        
        asyn (bool): Allows the arm to run in asynchronous mode
        
        payload (bool): Whether the arm currently has a payload (used in ECO mode)

    Returns: 
        
        None.

    &#34;&#34;&#34;

    if(v == &#34;ECO&#34;):
        if(payload == False):
            print()
            #Move at higher velocity
            rtde_c.moveL(targetTCP, v, a, asyn)

        elif(payload == True):
            print()
            #Reduce velocity by 20%
            rtde_c.moveL(targetTCP, v, a, asyn)

    else:
        #Assuming if v != ECO, is a int in string format
        v = int(v)
        rtde_c.moveL(targetTCP, 0.1, 0.1, asyn)
        print(&#34;MOVING TO POSITION&#34;)</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.pickParcel"><code class="name flex">
<span>def <span class="ident">pickParcel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickParcel(self):
    
    
    #At this point (in checkTCPValues) can read the sensor (switch), if nothing, move lower in the z axis by small increments)
    pass</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.placeParcel"><code class="name flex">
<span>def <span class="ident">placeParcel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def placeParcel(self):
    pass</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.receive"><code class="name flex">
<span>def <span class="ident">receive</span></span>(<span>self, conn)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns data received from server.</p>
<p>Args: </p>
<pre><code>conn (socket): socket connected to server.
</code></pre>
<p>Returns: </p>
<pre><code>jsonReceived (JSON - dictionary): returns json data.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receive(self, conn):
    
    &#34;&#34;&#34;
    Returns data received from server.
    
    Args: 
        
        conn (socket): socket connected to server.

    Returns: 
        
        jsonReceived (JSON - dictionary): returns json data. 
    &#34;&#34;&#34;
    jsonReceived = conn.recv(1024)
    jsonReceived = json.loads(jsonReceived.decode(&#34;utf-8&#34;))
    return jsonReceived</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, conn, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends data to the server. </p>
<p>Args: </p>
<pre><code>conn (socket): socket connected to server.

data (JSON - dictionary): data to send.
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, conn, data):
    
    &#34;&#34;&#34;
    Sends data to the server. 
    
    Args: 
        
        conn (socket): socket connected to server.
        
        data (JSON - dictionary): data to send. 

    Returns: 
        
        None.

    &#34;&#34;&#34;

    jsonResult = json.dumps(data)
    conn.send(bytes(jsonResult, encoding=&#34;utf-8&#34;))</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connects Arm Movement to the UR5 and the Server.</p>
<p>Starts up the rest of the functionality for the class. </p>
<p>Args: </p>
<pre><code>None.
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self):
    
    &#34;&#34;&#34;
    Connects Arm Movement to the UR5 and the Server.
    
    Starts up the rest of the functionality for the class. 
    
    Args: 
        
        None.

    Returns: 
        
        None.

    &#34;&#34;&#34;
    
    
    
    connected = False

    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    rtde_c = 0
    rtde_r = 0

    #Connect to arm
    while not(connected):
        try:
            #rtde_c = rtde_control.RTDEControlInterface(self.armIP)
           # rtde_r = rtde_receive.RTDEReceiveInterface(self.armIP)
            connected = True
        except Exception as e:
            print(e)
        finally:
            time.sleep(1)

    #Move arm to home position


    # Connect to server.
    connected = False
    while not(connected):
        try:
            conn.connect((self.serverIP, self.serverPORT))
            connected = True
        except Exception as e:
            print(e)
        finally:
            time.sleep(1)


    q = Queue()
    # t1 = threading.Thread(target = self.moniterUserInput, args = (q, conn, ))
    t2 = threading.Thread(target = self.TCPwrapper, args = (q, conn, rtde_c, rtde_r,  ))

    #t1.start()
    t2.start()

    #t1.join()
    t2.join()</code></pre>
</details>
</dd>
<dt id="Arm_Movement.Arm_Movement.stopRobot"><code class="name flex">
<span>def <span class="ident">stopRobot</span></span>(<span>self, rtde_c)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the arm with a joint deceleration of 2 rad/s^2</p>
<p>Args: </p>
<pre><code>rtde_c (class): Control interface for the arm (send stop command to arm).
</code></pre>
<p>Returns: </p>
<pre><code>None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopRobot(self, rtde_c):
    
    &#34;&#34;&#34;
    Stops the arm with a joint deceleration of 2 rad/s^2
    
    Args: 
        
        rtde_c (class): Control interface for the arm (send stop command to arm). 

    Returns: 
        
        None.

    &#34;&#34;&#34;
    rtde_c.stopJ(2.0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Arm_Movement.Arm_Movement" href="#Arm_Movement.Arm_Movement">Arm_Movement</a></code></h4>
<ul class="two-column">
<li><code><a title="Arm_Movement.Arm_Movement.TCPwrapper" href="#Arm_Movement.Arm_Movement.TCPwrapper">TCPwrapper</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.checkTCPValues" href="#Arm_Movement.Arm_Movement.checkTCPValues">checkTCPValues</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.checkVelocity" href="#Arm_Movement.Arm_Movement.checkVelocity">checkVelocity</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.moniterUserInput" href="#Arm_Movement.Arm_Movement.moniterUserInput">moniterUserInput</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.movRobot" href="#Arm_Movement.Arm_Movement.movRobot">movRobot</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.pickParcel" href="#Arm_Movement.Arm_Movement.pickParcel">pickParcel</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.placeParcel" href="#Arm_Movement.Arm_Movement.placeParcel">placeParcel</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.receive" href="#Arm_Movement.Arm_Movement.receive">receive</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.send" href="#Arm_Movement.Arm_Movement.send">send</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.setup" href="#Arm_Movement.Arm_Movement.setup">setup</a></code></li>
<li><code><a title="Arm_Movement.Arm_Movement.stopRobot" href="#Arm_Movement.Arm_Movement.stopRobot">stopRobot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>